#include "Drawer.hpp"

unsigned char letterTable[95][13] = {
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},// space :32
{0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18},// ! :33
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x36, 0x36, 0x36},
{0x00, 0x00, 0x00, 0x66, 0x66, 0xff, 0x66, 0x66, 0xff, 0x66, 0x66, 0x00, 0x00},
{0x00, 0x00, 0x18, 0x7e, 0xff, 0x1b, 0x1f, 0x7e, 0xf8, 0xd8, 0xff, 0x7e, 0x18},
{0x00, 0x00, 0x0e, 0x1b, 0xdb, 0x6e, 0x30, 0x18, 0x0c, 0x76, 0xdb, 0xd8, 0x70},
{0x00, 0x00, 0x7f, 0xc6, 0xcf, 0xd8, 0x70, 0x70, 0xd8, 0xcc, 0xcc, 0x6c, 0x38},
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x1c, 0x0c, 0x0e},
{0x00, 0x00, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x18, 0x0c},
{0x00, 0x00, 0x30, 0x18, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x18, 0x30},
{0x00, 0x00, 0x00, 0x00, 0x99, 0x5a, 0x3c, 0xff, 0x3c, 0x5a, 0x99, 0x00, 0x00},
{0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0xff, 0xff, 0x18, 0x18, 0x18, 0x00, 0x00},
{0x00, 0x00, 0x30, 0x18, 0x1c, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x00, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x60, 0x60, 0x30, 0x30, 0x18, 0x18, 0x0c, 0x0c, 0x06, 0x06, 0x03, 0x03},
{0x00, 0x00, 0x3c, 0x66, 0xc3, 0xe3, 0xf3, 0xdb, 0xcf, 0xc7, 0xc3, 0x66, 0x3c},
{0x00, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x38, 0x18},
{0x00, 0x00, 0xff, 0xc0, 0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x03, 0xe7, 0x7e},
{0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07, 0x7e, 0x07, 0x03, 0x03, 0xe7, 0x7e},
{0x00, 0x00, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0xff, 0xcc, 0x6c, 0x3c, 0x1c, 0x0c},
{0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07, 0xfe, 0xc0, 0xc0, 0xc0, 0xc0, 0xff},
{0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc7, 0xfe, 0xc0, 0xc0, 0xc0, 0xe7, 0x7e},
{0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x18, 0x0c, 0x06, 0x03, 0x03, 0x03, 0xff},
{0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xe7, 0x7e, 0xe7, 0xc3, 0xc3, 0xe7, 0x7e},
{0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x03, 0x7f, 0xe7, 0xc3, 0xc3, 0xe7, 0x7e},
{0x00, 0x00, 0x00, 0x38, 0x38, 0x00, 0x00, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x30, 0x18, 0x1c, 0x1c, 0x00, 0x00, 0x1c, 0x1c, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06},
{0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x03, 0x06, 0x0c, 0x18, 0x30, 0x60},
{0x00, 0x00, 0x18, 0x00, 0x00, 0x18, 0x18, 0x0c, 0x06, 0x03, 0xc3, 0xc3, 0x7e},
{0x00, 0x00, 0x3f, 0x60, 0xcf, 0xdb, 0xd3, 0xdd, 0xc3, 0x7e, 0x00, 0x00, 0x00},
{0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xff, 0xc3, 0xc3, 0xc3, 0x66, 0x3c, 0x18},
{0x00, 0x00, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe},
{0x00, 0x00, 0x7e, 0xe7, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xe7, 0x7e},
{0x00, 0x00, 0xfc, 0xce, 0xc7, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc7, 0xce, 0xfc},
{0x00, 0x00, 0xff, 0xc0, 0xc0, 0xc0, 0xc0, 0xfc, 0xc0, 0xc0, 0xc0, 0xc0, 0xff},
{0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xfc, 0xc0, 0xc0, 0xc0, 0xff},
{0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xcf, 0xc0, 0xc0, 0xc0, 0xc0, 0xe7, 0x7e},
{0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xff, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3},
{0x00, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7e},
{0x00, 0x00, 0x7c, 0xee, 0xc6, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06},
{0x00, 0x00, 0xc3, 0xc6, 0xcc, 0xd8, 0xf0, 0xe0, 0xf0, 0xd8, 0xcc, 0xc6, 0xc3},
{0x00, 0x00, 0xff, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0},
{0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xdb, 0xff, 0xff, 0xe7, 0xc3},
{0x00, 0x00, 0xc7, 0xc7, 0xcf, 0xcf, 0xdf, 0xdb, 0xfb, 0xf3, 0xf3, 0xe3, 0xe3},
{0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xe7, 0x7e},
{0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe},
{0x00, 0x00, 0x3f, 0x6e, 0xdf, 0xdb, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0x66, 0x3c},
{0x00, 0x00, 0xc3, 0xc6, 0xcc, 0xd8, 0xf0, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe},
{0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07, 0x7e, 0xe0, 0xc0, 0xc0, 0xe7, 0x7e},
{0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xff},
{0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3},
{0x00, 0x00, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3},
{0x00, 0x00, 0xc3, 0xe7, 0xff, 0xff, 0xdb, 0xdb, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3},
{0x00, 0x00, 0xc3, 0x66, 0x66, 0x3c, 0x3c, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3},
{0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3},
{0x00, 0x00, 0xff, 0xc0, 0xc0, 0x60, 0x30, 0x7e, 0x0c, 0x06, 0x03, 0x03, 0xff},
{0x00, 0x00, 0x3c, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3c},
{0x00, 0x03, 0x03, 0x06, 0x06, 0x0c, 0x0c, 0x18, 0x18, 0x30, 0x30, 0x60, 0x60},
{0x00, 0x00, 0x3c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x3c},
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc3, 0x66, 0x3c, 0x18},
{0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x38, 0x30, 0x70},
{0x00, 0x00, 0x7f, 0xc3, 0xc3, 0x7f, 0x03, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0xfe, 0xc3, 0xc3, 0xc3, 0xc3, 0xfe, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0},
{0x00, 0x00, 0x7e, 0xc3, 0xc0, 0xc0, 0xc0, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x7f, 0xc3, 0xc3, 0xc3, 0xc3, 0x7f, 0x03, 0x03, 0x03, 0x03, 0x03},
{0x00, 0x00, 0x7f, 0xc0, 0xc0, 0xfe, 0xc3, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x30, 0x33, 0x1e},
{0x7e, 0xc3, 0x03, 0x03, 0x7f, 0xc3, 0xc3, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xfe, 0xc0, 0xc0, 0xc0, 0xc0},
{0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x18, 0x00},
{0x38, 0x6c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x00, 0x00, 0x0c, 0x00},
{0x00, 0x00, 0xc6, 0xcc, 0xf8, 0xf0, 0xd8, 0xcc, 0xc6, 0xc0, 0xc0, 0xc0, 0xc0},
{0x00, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78},
{0x00, 0x00, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xfe, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xfc, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00},
{0xc0, 0xc0, 0xc0, 0xfe, 0xc3, 0xc3, 0xc3, 0xc3, 0xfe, 0x00, 0x00, 0x00, 0x00},
{0x03, 0x03, 0x03, 0x7f, 0xc3, 0xc3, 0xc3, 0xc3, 0x7f, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xe0, 0xfe, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0xfe, 0x03, 0x03, 0x7e, 0xc0, 0xc0, 0x7f, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x1c, 0x36, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x30, 0x00},
{0x00, 0x00, 0x7e, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3, 0xc3, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0xc3, 0xe7, 0xff, 0xdb, 0xc3, 0xc3, 0xc3, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0xc3, 0x66, 0x3c, 0x18, 0x3c, 0x66, 0xc3, 0x00, 0x00, 0x00, 0x00},
{0xc0, 0x60, 0x60, 0x30, 0x18, 0x3c, 0x66, 0x66, 0xc3, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0xff, 0x60, 0x30, 0x18, 0x0c, 0x06, 0xff, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x0f, 0x18, 0x18, 0x18, 0x38, 0xf0, 0x38, 0x18, 0x18, 0x18, 0x0f},
{0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18},
{0x00, 0x00, 0xf0, 0x18, 0x18, 0x18, 0x1c, 0x0f, 0x1c, 0x18, 0x18, 0x18, 0xf0},
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x8f, 0xf1, 0x60, 0x00, 0x00, 0x00}};


Drawer::Drawer(uint32_t* bufferPointer, int row_n, int col_n)
{
    this->buffer = bufferPointer;
    this->row_n = row_n;
    this->col_n = col_n;
}

Drawer::~Drawer()
{
}

void Drawer::zero(){
    memset(buffer, 0, row_n * col_n * sizeof(uint32_t));
}

void Drawer::fill(uint32_t color){
    for(int i = 0; i < row_n * col_n; i++){
        memcpy(buffer + i, &color, sizeof(uint32_t));
        //buffer[i] = color;
    }
}

void Drawer::line(uint32_t color, int x1, int y1, int x2, int y2){
    if(x1 > x2){ //reorder
        int tmp = x2;
        x2 = x1;
        x1 = tmp;
    }
    if(y1 > y2){
        int tmp = y2;
        y2 = y1;
        y1 = tmp;
    }

    //sanatize variables
    y1 = y1 < 0? 0 : y1;
    y2 = y2 > col_n? col_n : y2;
    x1 = x1 < 0? 0 : x1;
    x2 = x2 > row_n? row_n : x2;

    for(; x1 != x2 + 1; x1++){
        for(; y1 != y2 + 1; y1++){
            buffer[x1 * col_n + y1] = color;
        }
    }
}

void Drawer::fastHLine(uint32_t color, int x, int y1, int y2){
    if(y1 > y2){
        int tmp = y2;
        y2 = y1;
        y1 = tmp;
    }

    for(; y1 != y2; y1++){
        buffer[x * col_n + y1] = color;
    }
}

void Drawer::fastVLine(uint32_t color, int x1, int x2, int y){
    for(int x = x1; x <= x2; x++){
        buffer[x * col_n + y] = color;
    }
}

void Drawer::pixel(uint32_t color, int x, int y){
    if(x < 0 || x > row_n)
        return;

    if(y < 0 || x > col_n)
        return;

    buffer[(x * col_n) + y] = color;

}

//example of '!'
//0       ■ ■
//        ■ ■
//        ■ ■
//        ■ ■
//        ■ ■
//        ■ ■
//        ■ ■
//
//
//        ■ ■
//        ■ ■
//
//13
//  0 1 2 3 4 5 6 7

void Drawer::drawTextSmall(int x, int y, const char* str, uint32_t color, uint32_t fillColor){
        int strLength = strlen(str);
    if(strLength == 0 || x < -ASCII_HEIGHT || x >= row_n || y < -strLength * ASCII_WIDTH || y >= col_n){ //skips on writing if it won't be shown
        return;
    }

    //discard start letters that won't show
    int startLetter = 0;
    int startOffset = 0;
    if(y < 0){
        startLetter = -y / ASCII_WIDTH;
        startOffset = -y % ASCII_WIDTH;
    }

    int charN = (col_n / ASCII_WIDTH) + 1; //max for the screen
    if(charN < strLength && y > 0){ //skip non visible pixels
        charN = (col_n - y)/ASCII_WIDTH + 1;
    }
    else{ //don't generate pixels that won't show
        charN = charN < strLength - startLetter ? charN : strLength - startLetter;
    }

    uint32_t textBuf[ASCII_HEIGHT][charN * ASCII_WIDTH];
    for(int i = 0; i < ASCII_HEIGHT; i++){
        for(int j = 0; j < charN * ASCII_WIDTH; j++){
            textBuf[i][j] = 0;
        }
    }
    //memset(textBuf, 0, sizeof(uint32_t));

    //for(int h = ASCII_HEIGHT - 1; h >= 0; h--){
    for(int h = 0; h < ASCII_HEIGHT; h++){
        for(int i = 0; i < charN; i++){ //[.... ] -...-> [::::.] ...
            uint8_t c = str[i + startLetter];
            uint8_t l = letterTable[c - ASCII_START][h];
            for(int j = ASCII_WIDTH - 1; j >= 0; j--, l = l >> 1){
                textBuf[ASCII_HEIGHT - 1 - h][ASCII_WIDTH * i + j] = l & 1? color : fillColor; //0x18 >> 1 -> 0xc >> 1 -> 0x3 >> 1 -> 0x1 >> 1 -> 0 >> 1...
            }
        }
    }
    int heightCrop = (x + ASCII_HEIGHT) > row_n? row_n : (x + ASCII_HEIGHT);

    int destinationOff = y > 0? y : 0;
    int newWidth = (charN) * ASCII_WIDTH - startOffset;
    newWidth = newWidth > col_n - destinationOff? col_n - destinationOff: newWidth; //bound it to max

    for(int x1 = x > 0? x : 0; x1 < heightCrop; x1++){
        memcpy(buffer + col_n * x1 + destinationOff, textBuf[x1 - x] + startOffset, newWidth * sizeof (uint32_t)); //nPixels is not the correct val
    }
}

void Drawer::drawTextBig(int x, int y, const char* str, uint32_t color, uint32_t fillColor){
    int ascii_width = ASCII_WIDTH * 2;
    int ascii_height = ASCII_HEIGHT * 2;

    int strLength = strlen(str);
    if(strLength == 0 || x < -ascii_height || x > row_n || y < -strLength * ascii_width || y > col_n){ //skips on writing if it won't be shown
        return;
    }

    //discard letters that won't show
    int startLetter = 0;
    int startOffset = 0;
    if(y < 0){
        startLetter = -y / ascii_width;
        startOffset = -y % ascii_width;
    }

    int charN = (col_n / ascii_width) + 2; //1 causes problems before the right value
    if(charN < strLength && y > 0){ //skip non visible pixels
        charN = (col_n - y)/ascii_width + 1;
    }
    else{ //don't generate pixels that won't show
        charN = charN < strLength - startLetter ? charN : strLength - startLetter;
        //charN++;
    }

    uint32_t textBuf[ascii_height][charN * ascii_width];
    for(int i = 0; i < ascii_height; i++){
        for(int j = 0; j < charN * ascii_width; j++){
            textBuf[i][j] = 0;
        }
    }
    //memset(textBuf, 0, sizeof(textBuf));

    //for(int h = ASCII_HEIGHT - 1; h >= 0; h--){
    for(int h = 0; h < ASCII_HEIGHT; h++){
        for(int i = 0; i < charN; i++){ //[.... ] -...-> [::::.] ...
            uint8_t c = str[i + startLetter];
            uint8_t l = letterTable[c - ASCII_START][h];
            for(int j = ASCII_WIDTH - 1; j >= 0; j--, l = l >> 1){
                uint32_t colorToUse = l & 1? color : fillColor;
                textBuf[ascii_height - 2 - 2*h][ascii_width * i + 2*j] = colorToUse; //0x18 >> 1 -> 0xc >> 1 -> 0x3 >> 1 -> 0x1 >> 1 -> 0 >> 1...
                textBuf[ascii_height - 2 - 2*h][ascii_width * i + 2*j + 1] = colorToUse;
                textBuf[ascii_height - 2 - 2*h + 1][ascii_width * i + 2*j] = colorToUse;
                textBuf[ascii_height - 2 - 2*h + 1][ascii_width * i + 2*j + 1] = colorToUse;
            }
        }
    }
    int heightCrop = (x + ascii_height) > row_n? row_n : (x + ascii_height);


    int destinationOff = y > 0? y : 0;

    int newWidth = (charN) * ascii_width - startOffset;// - startOffset;
    newWidth = newWidth > col_n - destinationOff? col_n - destinationOff: newWidth; //bound it to max

    for(int x1 = x > 0? x : 0; x1 < heightCrop; x1++){
        memcpy(buffer + col_n * x1 + destinationOff, textBuf[x1 - x] + startOffset, newWidth * sizeof (uint32_t)); //nPixels is not the correct val
    }
}

void Drawer::rainbowFill(){
    for(int x = 0; x < row_n; x++){
        for(int y = 0; y < col_n; y++){
            uint32_t red = (x/(float)row_n) * 255;
            red &= 0xFF;
            uint32_t green = (y/(float)col_n) * 255;
            green &= 0xFF;
            uint32_t blue = (y%16 + 16*(x%16));
            blue &= 0xFF;
            buffer[x*col_n + y] = red << 24 | green << 16 | blue << 8;
        }
    }
}

void Drawer::rainbowTriangle(){
    for(int x = 0; x < row_n; x++){
        for(int y = 0; y < col_n; y++){
            uint32_t red = ((63-y)/(float)(col_n/2)) * 255;
            red &= 0xFF;
            uint32_t green = (y/(float)(col_n/2)) * 255;
            green &= 0xFF;
            uint32_t blue = (x /(float)col_n) * 255;
            blue &= 0xFF;
            
            if(y < x || y > 63-x)
                continue;
            buffer[x*col_n + y] = red << 24 | green << 16 | blue << 8;
        }
    }
}

void Drawer::rainbowFillIterativeScroll(){
    static uint32_t currColor = 0xFF000000; 
    uint32_t red = (currColor >> 24) & 0xFF;
    uint32_t green = (currColor >> 16) & 0xFF;
    uint32_t blue = (currColor >> 8) & 0xFF;

    bool update = true;
    for(int i = 0; i < col_n; i++){
        static int divider = 0;
        divider++;
        divider%=1;
        if(divider == 0){
            //where to subtract
            //where to add
            uint32_t *sub, *add;
            if(red != 0){
                if(blue == 0){ //covers red to green
                    sub = &red;
                    add = &green;
                }
                else{           //covers blue to red
                    sub = &blue;
                    add = &red;
                }
            }
            else if(green != 0){ //0x00XXXX
                sub = &green;
                add = &blue;
            }
            else{ //0x0000XX
                sub = &blue;
                add = &red;
            }
            
            (*add)++;
            (*sub)--;

        }
        
        uint32_t color = red << 24 | green << 16 | blue << 8;
        fastVLine(color, 0, 31, i);

        if(update){
            currColor = color;
            update = false;
            printf("Curr color: %x\n", currColor);
        }
    }

    //printf("\tIterated 0x%x\n", currColor);

}

void Drawer::rainbowFillIterative(){
    static uint32_t currColor = 0xFF000000; 
    uint32_t red = (currColor >> 24) & 0xFF;
    uint32_t green = (currColor >> 16) & 0xFF;
    uint32_t blue = (currColor >> 8) & 0xFF;

    uint32_t *sub, *add;
    if(red != 0){
        if(blue == 0){ //covers red to green
            sub = &red;
            add = &green;
        }
        else{           //covers blue to red
            sub = &blue;
            add = &red;
        }
    }
    else if(green != 0){ //0x00XXXX
        sub = &green;
        add = &blue;
    }
    else{ //0x0000XX
        sub = &blue;
        add = &red;
    }
    
    (*add)++;
    (*sub)--;
    
    currColor = red << 24 | green << 16 | blue << 8;
    fill(currColor);
    printf("Curr color: %x\n", currColor);
}


#define MAXDISTANCE 45
uint32_t distanceTo(int x1, int y1, int x2, int y2){
    x1 -= x2;
    y1 -= y2;

    if(y1 < 0)
        y1 = -y1;
    if(x1 < 0)
        x1 = -x1;

    double distance = MAXDISTANCE - sqrt(x1*x1 + y1*y1);

    distance /= MAXDISTANCE;
    distance *= 255;
    distance = abs(distance);
    return (uint32_t)distance;
}

void Drawer::rainbowTriangle2(){
    //corners
    //(0, 16) red
    //(0, 46) green
    //(27, 31) blue

    for(int x = 0; x < 29; x++){
        for(int y = 14; y < 49; y++){
            //p1 is (0, 15)
            float dx = x;
            float dy = y - 15;
            
            //p1 is (27, 31)
            float dx2 = x - 27;
            float dy2 = y - 31;

            float d1 = dy == 0? 10000 : dx/dy; //big fuck off value
            float d2 = dy2 == 0? 10000 : dx2/dy2;
            
            if(d1 < 0)
                d1 = -d1;
            if(d2 < 0)
                d2 = -d2;
            
            if((d1 < 1.75) && (d2 > 1.75)){
                static bool first = false;
                uint32_t distanceToRed = (distanceTo(0, 16, x, y));
                uint32_t distanceToGreen = (distanceTo(0, 46, x, y));
                uint32_t distanceToBlue = (distanceTo(26, 31, x, y));
                
                distanceToRed = distanceToRed > 0xFF? 0xFF : distanceToRed; 
                distanceToGreen = distanceToGreen > 0xFF? 0xFF : distanceToGreen;
                distanceToBlue = distanceToBlue > 0xFF? 0xFF : distanceToBlue;
                //distanceToRed &= 0xFF;
                //distanceToGreen &= 0xFF;
                //distanceToBlue &= 0xFF;
                
                uint32_t color = (distanceToRed << 24) | (distanceToGreen << 16) | (distanceToBlue << 8);
                if(!first && x == 0 && y == 16){
                    printf("(%d,%d) = 0x%x\n", x, y, color);
                }
                if(!first && x == 0 && y == 46){
                    printf("(%d,%d) = 0x%x\n", x, y, color);
                }
                if(!first && x == 27 && y == 31){
                    printf("(%d,%d) = 0x%x\n", x, y, color);
                }
                if(!first && x == 11 && y == 31){
                    printf("(%d,%d) = 0x%x\n", x, y, color);

                }
                if(!first){
                    first = true;
                }
                buffer[x * col_n + y] = color;
            }
            
        }
    }
}

void Drawer::ColorTest(){

    for(int y = 0; y < col_n; y++){
        uint32_t baseColor = (y*4) & 0xFF;

        //red
        pixel(baseColor << 24, 2, y);
        //green
        pixel(baseColor << 16, 6, y);
        //blue
        pixel(baseColor << 8, 10, y);

        //red + green
        pixel((baseColor<<24) + (baseColor << 16), 14, y);
        //red + blue
        pixel((baseColor<<24) + (baseColor << 8), 18, y);
        //blue + green
        pixel((baseColor << 16) + (baseColor << 8), 22, y);

        //white
        pixel((baseColor<<24) + (baseColor << 16) + (baseColor << 8), 26, y);
    }
}